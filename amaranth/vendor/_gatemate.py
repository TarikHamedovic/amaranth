from abc import abstractmethod
from amaranth import *
from amaranth.build import *
from amaranth.lib.cdc import ResetSynchronizer


<<<<<<< HEAD

__all__ = ["GateMatePlatform"]



=======
__all__ = ["GateMatePlatform"]


>>>>>>> 0580d1ab82319a37c4f787d360bd3e334ab7f0b2
class GateMatePlatform(TemplatedPlatform):
    """

    Required tools:
        * ``yosys``
        * ``p_r``

    The environment is populated by setting the ``AMARANTH_ENV_GATEMATE`` environment variable to point to the toolchain directory.
    """

    device = property(abstractmethod(lambda: None))
    package = property(abstractmethod(lambda: None))

    toolchain = "GateMate"

    required_tools = [
        "yosys",
        "p_r",
    ]

    file_templates = {
        **TemplatedPlatform.build_script_templates,
        "{{name}}.v": r"""
            /* {{autogenerated}} */
            {{emit_verilog()}}
        """,
        "{{name}}.debug.v": r"""
            /* {{autogenerated}} */
            {{emit_debug_verilog()}}
        """,
        "{{name}}.ccf": r"""
            # {{autogenerated}}
            {% for port_name, pin_name, attrs in platform.iter_port_constraints_bits() -%}
                Net "{{port_name}}" Loc = "{{pin_name}}"
                {%- for constraint, value in attrs.items() -%}
                | {{constraint}}={{value}}
                {%- endfor -%};
        {% endfor %}
        """,
        "{{name}}.sdc": r"""
            # {{autogenerated}}
            {% for net_signal, port_signal, frequency in platform.iter_clock_constraints() -%}
                {% if port_signal is not none -%}
                    create_clock -period {{1000000000/frequency}} [get_ports {{port_signal.name|tcl_quote}}]
                {% endif %}
            {% endfor %}
        """,
    }

    command_templates = [
        r"""
        mkdir -p log;
        mkdir -p net;
        {{invoke_tool("yosys")}}
            -ql log/synth.log -p 'read -sv {{name}}.v; synth_gatemate -top {{name}} -nomx8 -vlog net/{{name}}_synth.v'
        """,
        r"""

        {{invoke_tool("p_r")}}
            {{verbose("-v")}}
            -i net/{{name}}_synth.v
            -o {{name}}
            -ccf {{name}}.ccf
            -cCP > log/impl.log
        """,
    ]

    # Common logic

    @property
    def default_clk_constraint(self):
        if self.default_clk == "sys_clk0":
            return Clock(self.osc_freq / self.osc_div)
        return super().default_clk_constraint

    def add_clock_constraint(self, clock, frequency):
        super().add_clock_constraint(clock, frequency)
        clock.attrs["keep"] = "TRUE"

    def create_missing_domain(self, name):
        if name == "sync" and self.default_clk is not None:
            m = Module()
            if self.default_clk == "sys_clk0":
                if not hasattr(self, "osc_div"):
                    raise ValueError("OSC divider (osc_div) must be an integer between 2 and 512")
                if not isinstance(self.osc_div, int) or self.osc_div < 2 or self.osc_div > 512:
                    raise ValueError("OSC divider (osc_div) must be an integer between 2 and 512, not {!r}".format(self.osc_div))
                if not hasattr(self, "osc_freq"):
                    raise ValueError("OSC frequency (osc_freq) must be an integer between 2100000 and 80000000")
                if not isinstance(self.osc_freq, int) or self.osc_freq < 2100000 or self.osc_freq > 80000000:
                    raise ValueError("OSC frequency (osc_freq) must be an integer between 2100000 and 80000000, not {!r}".format(self.osc_freq))
                clk_i = Signal()
                sys_clk0 = Signal()
                m.submodules += Instance("qlal4s3b_cell_macro", o_Sys_Clk0=sys_clk0)
                m.submodules += Instance("gclkbuff", o_A=sys_clk0, o_Z=clk_i)
            else:
                clk_i = self.request(self.default_clk).i

            if self.default_rst is not None:
                rst_i = self.request(self.default_rst).i
            else:
                rst_i = Const(0)

            m.domains += ClockDomain("sync")
            m.d.comb += ClockSignal("sync").eq(clk_i)
            m.submodules.reset_sync = ResetSynchronizer(rst_i, domain="sync")
            return m

